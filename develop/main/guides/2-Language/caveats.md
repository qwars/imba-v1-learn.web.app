
# Ограничения

Если вы приходите из мира JavaScript, вам необходимо узнать несколько вещей, когда изучаете Imba. Imba не похож на CoffeeScript, в том смысле, что он не пытается быть всего лишь немного отличающимся диалектом JavaScript. Imba компилируется в JavaScript, но синтаксис и семантика Imba влияют на структуру вашего кода.

Если вы не знакомы с Ruby, многие элементы Imba могут показаться немного запутанными, пока вы не поймете концепции неявного self и неявного вызова функции. Любой идентификатор со строчной буквы, который не объявлен явно как переменная, рассматривается как неявный вызов метода на self текущей области видимости. analyzer / highlighter синтаксиса поможет, выделяя переменные по-разному.


## Неявный self

```imba
hello # компилируется в  this.hello()
# поскольку hello не является объявленной переменной
# принимая 'self' в качестве неявного контекста.
```

```imba
# объявить переменную hello
var hello = "string"

# Теперь hello будет просто обычным доступом к переменной.
hello # компилируется в   hello
```

> У Imba есть некоторые предопределенные глобальные переменные: `window`, `document`, `console`, `process`, `setTimeout`, `setInterval`, `clearTimeout`, `clearInterval`, `parseInt`, `parseFloat`, `__dirname`
> 
> Это означает, что эти переменные всегда будут разрешаться как переменные. Если вы определили метод console в объекте, его необходимо вызвать явно через self: `self.console('something')`  

### внешний

```imba
extern something
something
```

### self vs this

В Imba, self является неявным контекстом, подобно self в Ruby. Как вы скоро узнаете, self не прямо отображается на this в JavaScript. Self относится к this ближайшей «замкнутой» области видимости. Классы и методы являются замкнутыми областями видимости, в то время как функциональные выражения ими не являются. Когда вы привыкнете к этому, вы обнаружите, что это одна из вещей, которые делают программирование на Imba очень приятным.

```imba
class Item

    def update data
        # do something
        self

    def fetch
        request('/some-url') do |data|
            # functions as blocks are not closed scopes,
            # so the implicit self will still refer to the
            # self of the outer method.
            self.update data

```

> this *всегда* относится к this, который вы знаете и любите (или ненавидите) из JavaScript. Поэтому, если вам действительно необходимо получить доступ к this внутри обратного вызова или блока кода, вы должны использовать this явно.

## Неявный вызов

В Imba вы вызываете методы с помощью обычного оператора точки. В JavaScript car.start обратится к свойству start объекта car. В Imba это действительно *вызовет* метод start объекта car. Круглые скобки являются необязательными. Подробнее о причинах такого поведения можно прочитать [здесь]. Если вы думаете в терминах JavaScript, это может показаться неудобным и запутанным. То же самое поведение можно видеть в языках, таких как Ruby.

Как же тогда получить доступ к свойствам? В Imba вы можете сделать это с помощью car['start'], так же, как в JavaScript. Поскольку доступ к свойствам все еще широко используется при работе с внешними библиотеками, написанными на JavaScript, у нас также есть краткий синтаксис, использующий двоеточие без пробелов: car:start. Для новых пользователей это может вызывать некоторые сложности, но после нескольких часов работы с кодом это станет для вас естественным.

> Если вы постоянно используете object:access в своем коде на Imba, это, скорее всего, связано с тем, что вы мыслите в терминах JavaScript. В Imba класс должен предоставлять информацию и поведение через методы.

В отличие от Ruby, в Imba также есть неявные сеттеры. Поскольку в Imba все переменные явно объявлены, присваивание значения недекларированной переменной воспринимается как обычный вызов метода. Например, name = 1 будет обращаться к сеттеру и будет компилироваться


## Arguments

Аргументы метода могут быть доступны через специальное свойство $0. Каждый отдельный аргумент может быть доступен через $n, где n - это номер аргумента, начиная с 1.

```imba
def method
    $0 # -> arguments
    $1 # -> arguments[0]
    $2 # -> arguments[1]

# sometimes practical for inline methods
var doubles = [1,2,3].map do $1 * 2
```


