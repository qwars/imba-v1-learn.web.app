# Управление состоянием


Большинство фреймворков для разработки веб-приложений стремятся хорошо решать одну задачу: обновлять представления автоматически при изменении базовых данных.

Imba использует алгоритм согласования дома в совершенно новом стиле, который работает более чем [в 20 раз быстрее](https://somebee.github.io/dom-reconciler-bench/index.html) других подходов. Из-за этого нам действительно не нужно заботиться о управлении состоянием. Нет необходимости в наблюдаемых объектах, неизменяемых структурах данных и так далее.

Возможно, это звучит наивно, но это действительно так. Даже в сложной платформе, такой как [scrimba.com](https://scrimba.com), мы совсем не используем фреймворки управления состоянием. Наши данные не наблюдаются. Мы просто постоянно перерисовываем всё приложение. Это работает превосходно.

> Виртуальный DOM был оптимизирован в течение многих лет в Vue, React и других фреймворках. Как же это возможно, что Imba работает в 20 раз быстрее? Imba использует совершенно другой подход, в котором ваши **декларативные представления** компилируются в очень оптимизированный **встроенный кэшированный DOM**.

### Использование MobX, Redux, Apollo, Relay, ...

Вы свободны использовать любой фреймворк управления состоянием, который вам нравится, просто знайте, что если ваша единственная мотивация для использования таких фреймворков заключается в том, чтобы убедиться, что ваше представление автоматически обновляется вместе с данными, **вам это не нужно**. Единственное требование - это монтировать ваше корневое представление с помощью Imba.mount.


```imba
# Просто объект, содержащий состояние?!
var state = {x: 0, y: 0, title: "Something"}

tag App
    def onmousemove e
        state:x = e.x
        state:y = e.y

    def render
        <self>
            <h1> "Mouse is at {state:x or 0} {state:y or 0}"
            if state:x > 350
                <h2> "X is over 350!"

Imba.mount <App>
```


### Но мое приложение не обновляется?!

Стандартный подход Imba заключается в перерисовке приложения после каждого обработанного события DOM. Если обработчик является асинхронным (используя async/await или возвращая промис), Imba также будет выполнять повторную отрисовку после завершения этого промиса. Практически все изменения состояния в приложениях происходят в результате взаимодействия пользователя. В нескольких других случаях мы также можем вызывать Imba.commit вручную.

#### Получение данных через WebSocket

Если вы обновляете состояние на основе данных, полученных через сокет, вам нужно сообщить Imba, что что-то могло измениться. Самый простой способ сделать это - просто:

```imba
# Вызывайте Imba.commit после каждого сообщения из сокета.
mySocket.addEventListener('message') do Imba.commit
```

#### Получение данных с помощью fetch

Если вы получаете данные через XMLHttpRequest/Window.fetch, вам следует вызывать Imba.commit после завершения запроса. Если вы делаете это часто, вероятно, вам стоит создать обертку для fetch, которая автоматически вызывает Imba.commit.
```imba
def load
    var res = await window.fetch("/items")
    var data = await res.json
    MyState:items = data
    # Просто уведомьте Imba о том, что нужно перепланировать элементы.
    Imba.commit

```

